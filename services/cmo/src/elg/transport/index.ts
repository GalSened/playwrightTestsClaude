/**
 * Transport Adapter Interface
 * Provides abstraction for Agent-to-Agent (A2A) messaging
 * Supports Redis Streams (default) and NATS JetStream (optional)
 */

/**
 * Message envelope for A2A communication
 */
export interface TransportMessage {
  /**
   * Message ID (generated by transport)
   */
  id: string;

  /**
   * Topic/subject for routing
   */
  topic: string;

  /**
   * Message payload (serialized)
   */
  payload: Uint8Array;

  /**
   * Metadata
   */
  metadata: {
    /**
     * Trace ID for correlation
     */
    traceId?: string;

    /**
     * Message timestamp
     */
    timestamp: number;

    /**
     * Source agent ID
     */
    source?: string;

    /**
     * Destination agent ID
     */
    destination?: string;

    /**
     * Reply-to topic
     */
    replyTo?: string;

    /**
     * Correlation ID for request/response
     */
    correlationId?: string;

    /**
     * Custom headers
     */
    headers?: Record<string, string>;
  };
}

/**
 * Message acknowledgment
 */
export interface MessageAck {
  /**
   * Message ID
   */
  messageId: string;

  /**
   * Acknowledge success
   */
  ack(): Promise<void>;

  /**
   * Negative acknowledge (requeue or DLQ)
   */
  nack(reason?: string): Promise<void>;

  /**
   * Reject and move to DLQ
   */
  reject(reason?: string): Promise<void>;
}

/**
 * Subscription handle
 */
export interface Subscription {
  /**
   * Topic being subscribed to
   */
  topic: string;

  /**
   * Consumer/subscription ID
   */
  id: string;

  /**
   * Unsubscribe and cleanup
   */
  unsubscribe(): Promise<void>;

  /**
   * Check if subscription is active
   */
  isActive(): boolean;
}

/**
 * Message handler callback
 */
export type MessageHandler = (
  message: TransportMessage,
  ack: MessageAck
) => Promise<void>;

/**
 * Transport publish options
 */
export interface PublishOptions {
  /**
   * Trace ID for correlation
   */
  traceId?: string;

  /**
   * Source agent ID
   */
  source?: string;

  /**
   * Destination agent ID
   */
  destination?: string;

  /**
   * Reply-to topic
   */
  replyTo?: string;

  /**
   * Correlation ID
   */
  correlationId?: string;

  /**
   * Custom headers
   */
  headers?: Record<string, string>;

  /**
   * Time-to-live in milliseconds
   */
  ttl?: number;

  /**
   * Priority (1-10, 10 is highest)
   */
  priority?: number;
}

/**
 * Transport subscribe options
 */
export interface SubscribeOptions {
  /**
   * Consumer group name (for load balancing)
   */
  consumerGroup?: string;

  /**
   * Consumer name (unique within group)
   */
  consumerName?: string;

  /**
   * Auto-acknowledge messages
   */
  autoAck?: boolean;

  /**
   * Maximum concurrent messages
   */
  maxConcurrent?: number;

  /**
   * Prefetch count
   */
  prefetch?: number;

  /**
   * Start from beginning of stream
   */
  fromBeginning?: boolean;

  /**
   * Dead-letter queue topic
   */
  dlqTopic?: string;

  /**
   * Maximum retries before DLQ
   */
  maxRetries?: number;
}

/**
 * Transport statistics
 */
export interface TransportStats {
  /**
   * Total messages published
   */
  messagesPublished: number;

  /**
   * Total messages consumed
   */
  messagesConsumed: number;

  /**
   * Total messages acknowledged
   */
  messagesAcked: number;

  /**
   * Total messages negative acknowledged
   */
  messagesNacked: number;

  /**
   * Total messages moved to DLQ
   */
  messagesDlq: number;

  /**
   * Active subscriptions
   */
  activeSubscriptions: number;

  /**
   * Current pending messages
   */
  pendingMessages: number;

  /**
   * Transport-specific stats
   */
  custom?: Record<string, number>;
}

/**
 * Transport Adapter Interface
 * Abstracts message broker implementation
 */
export interface TransportAdapter {
  /**
   * Transport name (e.g., "redis-streams", "nats-jetstream")
   */
  name: string;

  /**
   * Connect to transport
   */
  connect(): Promise<void>;

  /**
   * Disconnect from transport
   */
  disconnect(): Promise<void>;

  /**
   * Check if connected
   */
  isConnected(): boolean;

  /**
   * Publish message to topic
   *
   * @param topic - Topic/subject to publish to
   * @param payload - Message payload (will be serialized)
   * @param options - Publish options
   * @returns Message ID
   */
  publish(
    topic: string,
    payload: Uint8Array,
    options?: PublishOptions
  ): Promise<string>;

  /**
   * Subscribe to topic
   *
   * @param topic - Topic/subject to subscribe to
   * @param handler - Message handler callback
   * @param options - Subscribe options
   * @returns Subscription handle
   */
  subscribe(
    topic: string,
    handler: MessageHandler,
    options?: SubscribeOptions
  ): Promise<Subscription>;

  /**
   * Request-response pattern
   * Publish and wait for response on reply-to topic
   *
   * @param topic - Request topic
   * @param payload - Request payload
   * @param options - Publish options
   * @param timeout - Response timeout in milliseconds
   * @returns Response message
   */
  request(
    topic: string,
    payload: Uint8Array,
    options?: PublishOptions,
    timeout?: number
  ): Promise<TransportMessage>;

  /**
   * Get transport statistics
   */
  getStats(): Promise<TransportStats>;

  /**
   * Health check
   */
  healthCheck(): Promise<{
    healthy: boolean;
    latency?: number;
    error?: string;
  }>;

  /**
   * Create topic/stream (if needed)
   */
  createTopic?(topic: string, options?: unknown): Promise<void>;

  /**
   * Delete topic/stream
   */
  deleteTopic?(topic: string): Promise<void>;

  /**
   * Purge messages from topic
   */
  purgeTopic?(topic: string): Promise<void>;
}

/**
 * Transport configuration
 */
export interface TransportConfig {
  /**
   * Transport type
   */
  type: 'redis-streams' | 'nats-jetstream';

  /**
   * Connection string or host
   */
  host: string;

  /**
   * Port
   */
  port: number;

  /**
   * Authentication
   */
  auth?: {
    username?: string;
    password?: string;
    token?: string;
  };

  /**
   * TLS configuration
   */
  tls?: {
    enabled: boolean;
    ca?: string;
    cert?: string;
    key?: string;
  };

  /**
   * Connection pool size
   */
  poolSize?: number;

  /**
   * Connection timeout in milliseconds
   */
  connectTimeout?: number;

  /**
   * Keepalive interval in milliseconds
   */
  keepaliveInterval?: number;

  /**
   * Transport-specific options
   */
  options?: Record<string, unknown>;
}

/**
 * Transport Factory
 */
export interface TransportFactory {
  /**
   * Create transport adapter from configuration
   */
  create(config: TransportConfig): TransportAdapter;
}
