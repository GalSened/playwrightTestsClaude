/**
 * Allure Reporting Integration Service
 * Integrates with Allure reports generated by pytest-based UI tests
 */

import { EventEmitter } from 'events';
import { spawn, ChildProcess } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { logger } from '@/utils/logger';

export interface AllureConfig {
  resultsDir: string;
  reportDir: string;
  categoriesPath?: string;
  trendsDir?: string;
  historyDir?: string;
}

export interface AllureReport {
  id: string;
  runId: string;
  status: 'generating' | 'completed' | 'failed';
  config: AllureConfig;
  reportPath?: string;
  htmlReportPath?: string;
  summary?: AllureTestSummary;
  startTime: Date;
  endTime?: Date;
  duration?: number;
  errors: string[];
}

export interface AllureTestSummary {
  total: number;
  passed: number;
  failed: number;
  broken: number;
  skipped: number;
  unknown: number;
  flaky: number;
  testStats: {
    [status: string]: number;
  };
  suites: Array<{
    name: string;
    tests: number;
    passed: number;
    failed: number;
    broken: number;
    skipped: number;
  }>;
  categories?: Array<{
    name: string;
    count: number;
    messageRegex?: string;
    traceRegex?: string;
  }>;
  trends?: {
    passed: number[];
    failed: number[];
    broken: number[];
    skipped: number[];
  };
}

export class AllureReporter extends EventEmitter {
  private static readonly DEFAULT_RESULTS_DIR = path.resolve(__dirname, '../../../data/allure/results');
  private static readonly DEFAULT_REPORTS_DIR = path.resolve(__dirname, '../../../data/allure/reports');

  private activeReports: Map<string, AllureReport> = new Map();
  private runningProcesses: Map<string, ChildProcess> = new Map();

  constructor() {
    super();
    this.ensureDirectories();
  }

  private ensureDirectories(): void {
    [
      AllureReporter.DEFAULT_RESULTS_DIR,
      AllureReporter.DEFAULT_REPORTS_DIR
    ].forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        logger.info(`Created Allure directory: ${dir}`);
      }
    });
  }

  async generateReport(runId: string, config?: Partial<AllureConfig>): Promise<string> {
    const reportId = uuidv4();
    const fullConfig: AllureConfig = {
      resultsDir: config?.resultsDir || path.join(process.cwd(), 'new_tests_for_wesign', 'allure-results'),
      reportDir: config?.reportDir || path.join(AllureReporter.DEFAULT_REPORTS_DIR, reportId),
      categoriesPath: config?.categoriesPath,
      trendsDir: config?.trendsDir,
      historyDir: config?.historyDir
    };

    logger.info(`ðŸ“Š Starting Allure report generation: ${reportId}`, { runId, config: fullConfig });

    const report: AllureReport = {
      id: reportId,
      runId,
      status: 'generating',
      config: fullConfig,
      startTime: new Date(),
      errors: []
    };

    this.activeReports.set(reportId, report);

    try {
      // Validate results directory exists and has content
      await this.validateResultsDirectory(fullConfig.resultsDir);

      // Generate the report
      await this.executeAllureGenerate(reportId, fullConfig);

      return reportId;
    } catch (error: any) {
      report.status = 'failed';
      report.errors.push(`Report generation failed: ${error.message}`);
      this.emit('reportError', { reportId, runId, error: error.message });
      throw error;
    }
  }

  private async validateResultsDirectory(resultsDir: string): Promise<void> {
    if (!fs.existsSync(resultsDir)) {
      throw new Error(`Allure results directory not found: ${resultsDir}`);
    }

    const files = fs.readdirSync(resultsDir).filter(file =>
      file.endsWith('.json') || file.endsWith('.txt') || file.endsWith('.properties')
    );

    if (files.length === 0) {
      throw new Error(`No Allure result files found in: ${resultsDir}`);
    }

    logger.debug(`Validated Allure results directory: ${resultsDir} (${files.length} files)`);
  }

  private async executeAllureGenerate(reportId: string, config: AllureConfig): Promise<void> {
    const report = this.activeReports.get(reportId)!;

    // Ensure report directory exists
    if (!fs.existsSync(config.reportDir)) {
      fs.mkdirSync(config.reportDir, { recursive: true });
    }

    // Build Allure command arguments
    const args = this.buildAllureCommand(config);

    logger.info(`ðŸ“‹ Running Allure command: allure generate ${args.join(' ')}`);

    // Start Allure process
    const allureProcess = spawn('allure', ['generate', ...args], {
      cwd: process.cwd(),
      stdio: ['pipe', 'pipe', 'pipe']
    });

    this.runningProcesses.set(reportId, allureProcess);

    let stdout = '';
    let stderr = '';

    // Handle stdout
    allureProcess.stdout?.on('data', (data: Buffer) => {
      const output = data.toString();
      stdout += output;
      this.emit('reportProgress', { reportId, runId: report.runId, output });
    });

    // Handle stderr
    allureProcess.stderr?.on('data', (data: Buffer) => {
      const error = data.toString();
      stderr += error;
      report.errors.push(error);
      this.emit('reportError', { reportId, runId: report.runId, error });
    });

    // Handle process completion
    allureProcess.on('close', async (code) => {
      this.runningProcesses.delete(reportId);
      report.endTime = new Date();
      report.duration = report.endTime.getTime() - report.startTime.getTime();

      if (code === 0) {
        report.status = 'completed';
        report.reportPath = config.reportDir;
        report.htmlReportPath = path.join(config.reportDir, 'index.html');

        // Parse the generated report
        try {
          report.summary = await this.parseGeneratedReport(config.reportDir);
          logger.info(`âœ… Allure report generated successfully: ${reportId}`);
        } catch (parseError: any) {
          logger.warn(`âš ï¸ Report generated but parsing failed: ${parseError.message}`);
        }

        this.emit('reportComplete', { reportId, runId: report.runId, report });
      } else {
        report.status = 'failed';
        report.errors.push(`Allure process failed with exit code: ${code}`);
        report.errors.push(`STDOUT: ${stdout}`);
        report.errors.push(`STDERR: ${stderr}`);

        logger.error(`âŒ Allure report generation failed: ${reportId} (exit code: ${code})`);
        this.emit('reportError', { reportId, runId: report.runId, error: `Process failed with code ${code}` });
      }
    });

    // Handle process errors
    allureProcess.on('error', (error) => {
      this.runningProcesses.delete(reportId);
      report.status = 'failed';
      report.endTime = new Date();
      report.errors.push(`Process error: ${error.message}`);

      logger.error(`ðŸ’¥ Allure process error: ${reportId}`, error);
      this.emit('reportError', { reportId, runId: report.runId, error: error.message });
    });
  }

  private buildAllureCommand(config: AllureConfig): string[] {
    const args: string[] = [];

    // Input directory (results)
    args.push(config.resultsDir);

    // Output directory (report)
    args.push('--output', config.reportDir);

    // Clean output directory
    args.push('--clean');

    // Categories file
    if (config.categoriesPath && fs.existsSync(config.categoriesPath)) {
      args.push('--categories', config.categoriesPath);
    }

    return args;
  }

  private async parseGeneratedReport(reportDir: string): Promise<AllureTestSummary> {
    const dataDir = path.join(reportDir, 'data');

    if (!fs.existsSync(dataDir)) {
      throw new Error(`Allure report data directory not found: ${dataDir}`);
    }

    const summary: AllureTestSummary = {
      total: 0,
      passed: 0,
      failed: 0,
      broken: 0,
      skipped: 0,
      unknown: 0,
      flaky: 0,
      testStats: {},
      suites: []
    };

    try {
      // Parse summary data from widgets
      const suitesSummaryPath = path.join(dataDir, 'suites.json');
      if (fs.existsSync(suitesSummaryPath)) {
        const suitesData = JSON.parse(fs.readFileSync(suitesSummaryPath, 'utf-8'));
        this.parseSuitesData(summary, suitesData);
      }

      // Parse overall statistics
      const summaryWidgetPath = path.join(dataDir, 'summary.json');
      if (fs.existsSync(summaryWidgetPath)) {
        const summaryData = JSON.parse(fs.readFileSync(summaryWidgetPath, 'utf-8'));
        this.parseStatisticsData(summary, summaryData);
      }

      // Parse categories if available
      const categoriesPath = path.join(dataDir, 'categories.json');
      if (fs.existsSync(categoriesPath)) {
        const categoriesData = JSON.parse(fs.readFileSync(categoriesPath, 'utf-8'));
        summary.categories = categoriesData;
      }

      logger.debug(`Parsed Allure report summary:`, summary);
      return summary;

    } catch (error: any) {
      logger.warn(`Failed to parse Allure report data: ${error.message}`);
      throw error;
    }
  }

  private parseSuitesData(summary: AllureTestSummary, suitesData: any): void {
    if (suitesData && Array.isArray(suitesData.children)) {
      for (const suite of suitesData.children) {
        if (suite.name) {
          const suiteInfo = {
            name: suite.name,
            tests: suite.statistic?.total || 0,
            passed: suite.statistic?.passed || 0,
            failed: suite.statistic?.failed || 0,
            broken: suite.statistic?.broken || 0,
            skipped: suite.statistic?.skipped || 0
          };
          summary.suites.push(suiteInfo);
        }
      }
    }
  }

  private parseStatisticsData(summary: AllureTestSummary, statisticsData: any): void {
    if (statisticsData && statisticsData.statistic) {
      const stats = statisticsData.statistic;
      summary.total = stats.total || 0;
      summary.passed = stats.passed || 0;
      summary.failed = stats.failed || 0;
      summary.broken = stats.broken || 0;
      summary.skipped = stats.skipped || 0;
      summary.unknown = stats.unknown || 0;

      // Build test stats object
      summary.testStats = {
        passed: summary.passed,
        failed: summary.failed,
        broken: summary.broken,
        skipped: summary.skipped,
        unknown: summary.unknown
      };
    }
  }

  async getReport(reportId: string): Promise<AllureReport | null> {
    return this.activeReports.get(reportId) || null;
  }

  async getReportContent(reportId: string): Promise<string | null> {
    const report = this.activeReports.get(reportId);

    if (!report || !report.htmlReportPath || !fs.existsSync(report.htmlReportPath)) {
      return null;
    }

    return fs.readFileSync(report.htmlReportPath, 'utf-8');
  }

  async cancelReport(reportId: string): Promise<boolean> {
    const process = this.runningProcesses.get(reportId);

    if (process && !process.killed) {
      process.kill('SIGTERM');

      const report = this.activeReports.get(reportId);
      if (report) {
        report.status = 'failed';
        report.endTime = new Date();
        report.errors.push('Report generation cancelled');
      }

      this.runningProcesses.delete(reportId);
      logger.info(`ðŸ›‘ Allure report generation cancelled: ${reportId}`);
      return true;
    }

    return false;
  }

  async cleanup(): Promise<void> {
    // Clean up old report directories (keep last 10)
    try {
      const reportDirs = fs.readdirSync(AllureReporter.DEFAULT_REPORTS_DIR)
        .map(dir => ({
          name: dir,
          path: path.join(AllureReporter.DEFAULT_REPORTS_DIR, dir),
          stats: fs.statSync(path.join(AllureReporter.DEFAULT_REPORTS_DIR, dir))
        }))
        .filter(item => item.stats.isDirectory())
        .sort((a, b) => b.stats.mtime.getTime() - a.stats.mtime.getTime());

      if (reportDirs.length > 10) {
        const dirsToDelete = reportDirs.slice(10);
        for (const dir of dirsToDelete) {
          fs.rmSync(dir.path, { recursive: true, force: true });
          logger.info(`Cleaned up old Allure report: ${dir.name}`);
        }
      }
    } catch (error: any) {
      logger.warn(`Failed to cleanup old Allure reports: ${error.message}`);
    }
  }

  // Check if Allure CLI is available
  static async checkAllureAvailability(): Promise<boolean> {
    return new Promise((resolve) => {
      const allureCheck = spawn('allure', ['--version'], { stdio: 'pipe' });

      allureCheck.on('close', (code) => {
        resolve(code === 0);
      });

      allureCheck.on('error', () => {
        resolve(false);
      });
    });
  }
}

// Create singleton instance
export const allureReporter = new AllureReporter();